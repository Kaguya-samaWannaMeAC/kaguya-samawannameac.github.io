# 2021-05-06~

## **CF1083C**

### 题意

$n$ 个点的树，节点上的权值是一个排列，有 $q$ 次以下两种操作：

- 交换两个点的权值。

- 求所有路径上点构成 $\operatorname{mex}$ 的最大值。

($2 \le n \le 2 \times 10^5$，$1 \le q \le 2 \times 10^5$)

### 题解

设 $d(x,y)$ 是 $x,y$ 两点间距离，$b$ 在 $a,c$ 路径上的条件是 $d(a,b)+d(b,c)=d(a,c)$。

利用这个条件维护权值线段树，区间 $[l,r]$ 即权值在这个区间的点是否都在一条路径上，如果是则维护其两个端点。

修改操作直接修改即可，查询操作在线段树上进行二分，找到最长的前缀满足其构成一条路径即可，时间复杂度 $O(q\log n)$。

## **CF1313D**

### 题意

$n$ 个魔法，$m$ 个小朋友，每个魔法可以让 $[L_i,R_i]$ 中的小朋友获得一颗糖，每个魔法可以选择用或者不用，问最多能让多少个小朋友获得奇数个糖。保证就算所有魔法都用了，每个小朋友至多获得 $k$ 个糖。($1 \le n \le 10^5$，$1 \le m \le 10^9$，$1 \le k \le 8$)

### 题解

离散化后每个点最多被 $k$ 个区间覆盖，可以使用状压 dp，为当前覆盖该点的所有区间编个号并用二进制表示是否释放，这样就知道离散化后每个点是否会被覆盖奇数次，每个区间是否释放时要在左端点决定。

时间复杂度为 $O\left(n\left(\log n + 2^k\right)\right)$。

## **CF1313E**

### 题意

给定三个字符串 $a,b,s$，问有多少个 $[l_1,r_1],[l_2,r_2]$ 满足：

- $[l_1,r_1],[l_2,r_2]$ 相交。
- $a[l_1,r_1]b[l_2,r_2]=s$。

($1 \le |a|,|b| \le 5 \times 10^5$，$2 \le |s| \le 2n$)

### 题解

使用扩展 KMP 求出 $a$ 的每个后缀和 $s$ 的 LCP，以及 $b$ 的每个前缀和 $s$ 的 LCS。对于第 $i$ 个前缀或后缀，分别记为 $A_i$ 和 $B_i$。

对于一对 $A_i$ 和 $B_j$，它们能构成一组解当且仅当：

- $A_i + B_j \ge |s|$。
- $i \le j \le i + |s| - 1$。

且这样的解的个数恰好为 $A_i + B_j - |s| + 1$。

因此从小到大枚举 $A_i$，依次添加符合条件的 $B_i$，并使用树状数组维护第二个条件即可，时间复杂度为 $O(|b| \log n)$。

## **CF1326F**

### 题意

给出一个 $n$ 个点无向图的邻接矩阵，对于一个 $1$ 到 $n$ 的排列 $a_1,a_2,\cdots,a_n$，按如下方式生成一个长度为 $n-1$ 的 $\texttt{01}$ 串 $b_1b_2\cdots b_{n-1}$：

- 如果 $a_i$ 和 $a_{i+1}$ 之间有边，则 $b_i=\texttt{1}$，否则 $b_i=\texttt{0}$。

问对于 $2^{n-1}$ 个 $\texttt{01}$ 串，分别有多少个排列能生成它们。($2 \le n \le 18$)

### 题解

考虑将条件改为：

- 如果 $b_i=\texttt{1}$，则  $a_i$ 和 $a_{i+1}$ 之间有边。

这样求出来答案后 $i$ 的答案会包含在它的所有子集中，因此再做一遍 AND 的 IFWT 即可。

条件更改后，每个二进制串即对应图中数条链，且链与链之间相互独立不需要考虑首尾是否相连。

因此，每个二进制串对应的方案数只与将 $n$ 个节点分为数个链所代表的分拆数有关，而 $p_{18}=385$。

先使用状压 dp 求出每个子集有多少对应的链，设 $g_{i,j}$ 为当前集合为 $i$ 末尾为 $j$ 的链的方案数，$O(n)$ 转移，时间复杂度为 $O(n^22^n)$。

求出 $i$ 个元素组成的子集对应的链数量的数组 $f_i$，有 $f_{i,j} = \sum \limits _{\operatorname{popcount}(k)=i}\sum \limits _{l \in k}g_{k,l}$，对每个 $f_i$ 数组做 OR 的 FWT。

枚举每一种分拆方案，将对应的 $f_i$ 数组乘起来，做一遍 OR 的 IFWT，第 $2^n-1$ 项即为对应的方案数。注意到一共只有 $n$ 个 $\texttt{1}$，因此如果方案中有交最后肯定不能变为全 $\texttt{1}$，从而不需要使用子集卷积。

最后枚举 $0$ 到 $2^n-1$，通过其分拆方案得到其对应的方案数，做一遍 AND 的 IFWT 得到答案。

总时间复杂度为 $O\left(2^n\left(p_n+n^2\right)\right)$。

## **CF1515H**

### 题意

维护一个数据结构，初始有 $n$ 个数 $a_1,a_2,\cdots,a_n$，需要支持 $q$ 次以下四种操作之一：

- 将 $l_i \le a_i \le r_i$ 的所有 $a_i$ 变成 $a_i$ AND $x$。
- 将 $l_i \le a_i \le r_i$ 的所有 $a_i$ 变成 $a_i$ OR $x$。
- 将 $l_i \le a_i \le r_i$ 的所有 $a_i$ 变成 $a_i$ XOR $x$。
- 询问有多少个不同的 $a_i$ 满足 $l_i \le a_i \le r_i$。

($1 \le n \le 2 \times 10^5$，$1 \le q \le 10^5$，$0 \le a_i,x,l_i,r_i < 2^{20}$)

### 题解

设全集 $S=2^{20}-1$，异或 $S$ 等价于取反，因此可以通过 OR 和 XOR 操作实现 AND，下面只考虑 OR 和 XOR 这两种操作：

维护一个 $\texttt{01}$ Trie，维护每个节点对应的子树中叶子节点的数量 (因为题目中问的是不同的 $a_i$)，同时支持合并和分裂，可以取出对应区间的 Trie，原理和方法与线段树合并 / 分裂完全相同。

XOR 操作直接在分裂出来的树根打异或标记即可。

OR 操作则需要从根开始进行递归，如果 $x$ 这一位是 $\texttt{1}$ 则直接将左子树合并到右子树并删掉左子树，递归右子树；否则直接递归左右子树。直接这样做复杂度肯定是错误的，我们需要记录每个子树中每一位是否全是 $\texttt{0}$ 以及每一位是否全是 $\texttt{1}$，如果 $x$ 是 $\texttt{1}$ 的位在子树中要么全是 $\texttt{0}$ 要么全是 $\texttt{1}$，我们就可以用一个异或标记来取代继续递归，只需将那些全是 $\texttt{0}$ 的位进行异或即可。

上述信息的维护比较简单，唯一需要注意的是异或时两者也会跟着变化，需要进行一下讨论，不过依旧是按位运算，可以 $O(1)$ 完成。

这样做的时间复杂度为 $O\left((n+q) \log ^2 n\right)$，简单证明如下：

> 初始节点数 $O(n \log n)$，单次分裂操作至多增加 $O(\log n)$ 个节点，其它操作不会新增节点，因此总节点数不超过 $O\left((n+q)\log n\right)$。
>
> 合并操作中，如果继续递归没有终止那么必然会让一个节点永远消失，从而时间复杂度不超过节点总数，即为 $O\left((n+q)\log n\right)$。
>
> OR 操作递归过程中，如果继续递归没有终止那么必然会在子树中发生节点的合并，也就是至少会让一个节点永远消失，那么最多发生 $O\left((n+q)\log n\right)$ 次，而每次额外花费的时间不超过从根节点走到该点的时间，即为树高 $O(\log n)$，因此总时间复杂度不超过 $O\left((n+q) \log ^2 n\right)$。

## **CF1515I**

### 题意

$n$ 种钻石，第 $i$ 种数量为 $a_i$、重量为 $w_i$、价值为 $v_i$，执行 $m$ 次以下三种操作之一：

- 增加一定数量的第 $i$ 种钻石。
- 减少一定数量的第 $i$ 种钻石。
- 拿一个容量为 $c$ 的背包，按照价值从大到小、价值相同按重量从小到大的顺序依次拿钻石所有能拿的钻石，直到背包放不下为止，问背包中所有钻石的价值是多少。

($1 \le n \le 2 \times 10^5$，$1 \le m \le 10^5$，$1 \le c \le 10^{18}$)

### 题解

物品种类是固定的，先按照题目要求将物品排序。

考虑不停让 $c$ 不停减半，设 $c$ 的最高位为 $2^k$，那么只需考虑所有最高位不超过 $2^k$ 的物品，我们设 $<2^{k}$ 的物品为轻物品，其它 $< 2^{k+1}$ 但 $\ge 2^k$ 的物品为重物品，显然只能购买一个重物品。

对于每个 $k$，线段树维护以下两类值：

- 区间内所有轻物品的重量和和价值和。
- 区间内重量和最小的「重物品 + 其前面的所有轻物品」。

这两类值都可以 $O(\log c)$ 合并。

考虑按如下方法在线段树上递归，同时不断维护 $c$ 及其最高位 $2^k$，以及拿走物品的价值和：

- 如果该节点是叶子节点，则直接进行处理，修改价值和以及 $c$。
- 如果该区间内所有物品的重量和不超过 $c$，这可以通过该节点 $k+1$ 对应的轻物品重量和来获取，则直接进行处理，修改价值和以及 $c$。
- 如果该区间内所有轻物品的重量和不超过 $c$，同时该区间内不存在一个重物品满足其「重物品 + 其前面的所有轻物品」的重量和不超过 $c$，则必然会将所有的轻物品拿光，因此直接进行处理，修改价值和以及 $c$。
- 否则，递归左右子树。

可以证明单次操作这样做的时间复杂度为 $O(\log c\log n)$：

> 只需证明最多发生 $O(\log c)$ 次递归左右子树。
>
> 递归左右子树一定是因为它不满足前面的三种情况：
>
> - 要么该区间内存在一个重物品满足其「重物品 + 其前面的所有轻物品」的重量和不超过 $c$，如果这个重物品在左子树，那么递归完左子树回来 $c$ 至少减少一半；如果在右子树，那么左子树必然满足轻物品重量之和不超过 $c$，直接终止递归，相当于没有发生递归左右子树。
> - 要么该区间内所有轻物品的重量和大于 $c$，且不存在上述的重物品，那么如果左子树满足轻物品重量之和不超过 $c$，直接终止递归，相当于没有发生递归左右子树；否则，递归完左子树回来 $c$ 至少减少一半，因为 $c$ 变得小于一个轻物品。
>
> 综上，要么只会往一个子树继续走，相当于没有发生递归左右子树；要么递归完左子树 $c$ 至少减少一半，因此最多发生 $O(\log c)$ 次递归左右子树。

因为单次修改操作的时间复杂度是 $O\left(\log n \log c\right)$，因此总时间复杂度为 $O(m\log n\log c)$。

一个 trick 是不需要将 $k$ 的最大值设为 $60$，只需保证 $2^k$ 大于所有物品的重量，因为 $k$ 再大所有物品都是轻物品，不需要维护很多一样的东西，维护 $c$ 的最高位时也默认和 $k$ 的最大值取 $\min$ 即可。

## **CF1525F**

### 题意



### 题解



## **CF1526E**

### 题意

给定一个长度为 $n$ 的后缀数组和字符集大小 $k$，求有多少种不同的字符串。($1 \le n,k \le 2 \times 10^5$)

### 题解

首先下式必然成立：
$$
s_{\text{sa}_1} \le s_{\text{sa}_2} \le \cdots \le s_{\text{sa}_n}
$$
考虑哪些 $\le$ 可以被替换为 $<$，如果 $s_{\text{sa}_i}=s_{\text{sa}_{i+1}}$，那么这两个后缀删除第一个字符后对应的两个后缀仍然是前者更小，因此有 $\text{rk}_{\text{sa}_i+1} < \text{rk}_{\text{sa}_{i+1}+1}$。

另一方面，如果 $\text{rk}_{\text{sa}_i+1} < \text{rk}_{\text{sa}_{i+1}+1}$，那么 $s_{\text{sa}_i}$ 可以和 $s_{\text{sa}_{i+1}}$ 相等，因此有 $s_{\text{sa}_i}\le s_{\text{sa}_{i+1}}$。

综上，我们可以判断哪些位置可以取等号，假设有 $m$ 个位置可以取等号，则答案为：
$$
\sum_{i=0}^m\binom{m}{i}\binom{k}{n-i}=\binom{m+k}{n}
$$

## **CF1526F**

### 题意

交互题，有一个 $1$ 到 $n$ 的未知的排列 $p_1,p_2,\cdots,p_n$，仅知道 $p_1<p_2$，你可以至多询问 $2n+420$ 次如下问题：

- 给出三个不同的整数 $1 \le a,b,c \le n$，返回 $\max(|p_a-p_b|,|p_a-p_c|,|p_b-p_c|)$。

你需要猜出这个排列。($1 \le n \le 10^5$)

### 题解

返回的数相当于三个数排序后中间差值较大的那一个。

我们如果能得到 $1,2$ 或 $n,n-1$ 在哪儿，就能再问 $n-2$ 次把剩下的都给问出来。

如果我们能找到两个值相差足够小的位置，然后把其它位置的数都问一遍，那么返回的值最大的那个就是 $1$ 或者 $n$，次大的就可能是 $2,n-1$。

题解给出的这个最小范围是 $$

## **CF1528D**

### 题意



### 题解



## **CF1528E**

### 题意



### 题解



## **CF1528F**

### 题意



### 题解



## **CF1528G**

### 题意



### 题解



## **CF1528H**

### 题意



### 题解



## **CF1534E**

### 题意



### 题解



## **CF1534F**

### 题意



### 题解



## **CF1535F**

### 题意



### 题解



## **CF1536E**

### 题意



### 题解



## **CF1536F**

### 题意



### 题解



## **CF1539E**

### 题意



### 题解



## **CF1539F**

### 题意



### 题解



## **CF1536E**

### 题意



### 题解



## **CF1543E**

### 题意



### 题解



## **CF1545C**

### 题意



### 题解



## **CF1545D**

### 题意



### 题解





