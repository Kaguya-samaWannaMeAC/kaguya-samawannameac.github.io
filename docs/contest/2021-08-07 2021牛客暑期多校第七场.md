# [2021牛客暑期多校第七场](https://ac.nowcoder.com/acm/contest/11258)

| 排名    | 当场过题数 | 至今过题数 | 总题数 |
| ------- | ---------- | ---------- | ------ |
| 56/1294 | 3          | 7          | 11     |

## **A**

**upsolved by **

### 题意



### 题解



## **B**

**upsolved by **

### 题意



### 题解



## **C**

**upsolved by 2sozx**

### 题意

对于一个数 $x$ 每次操作后能变为 $x + \operatorname{popcount}(x)$ ，$10^7$ 个询问，每次询问 $a, b$ ，问对 $a$ 进行无限次操作后，第一个大于等于 $b$ 的数是多少，最后一起输出。 $1\le a < b < 2^{64}$

### 题解

首先我们可以发现一个显然的结论，每次移动不超过 $64$ 次，因此我们可以将 $x$ 分解，设其为 $x = M \times 2^6 + m$

首先我们定义一个数组 $f_{i, j, k}$ 表示第 $0\sim i - 1$ 位为 $0$，$m$ 为 $j$ ，$i\sim 57$ 位的 $\operatorname{popcount}$ 为 $k$ ，经过很多次移动后 $i\sim 57$ 位发生变化后 $m$ 最小是多少，这里将最后 $6$ 位与前面的 $58$ 位分开考虑。通过这个定义我们可以很容易的想出来这个 $f$ 的转移。详细的说就是 $i \not= 0$ 时，相当于 $i - 1$ 位变化两次；$i = 0$ 是让 $m$ 进位即可。


$$
f_{i,j,k} =
\begin{cases}
j + \operatorname{popcount}(j) + k - 64\quad i = 0 \wedge j + \operatorname{popcount}(j) + k \ge 64\newline
f_{i, j + \operatorname{popcount}(j) + k,k}\quad i = 0 \wedge j + \operatorname{popcount}(j) + k < 64\newline
f_{i - 1, f_{i - 1, j, k}, k + 1} \quad i \not= 0
\end{cases}
$$


转移的复杂度是 $O(64^3)$ 的。有了这个东西我们考虑如何用 $f$ 来计算答案。

考虑 $a, b$ 的二进制表示，我们可以从地位到高位转移 $a$ ，如果从这位开始，$a,b$ 到最高位的二进制表示完全相同，那么我们就可以用 $f$ 数组从这位向低位让 $a$ 始终贴着 $b$ 的上界即可。如果到最高位的二进制表示不同，那么为了要用上我们的 $f$ 数组，需要让这位的 $a$ 变成 $0$ ，然后继续考虑更高的一位。

这个做法复杂度是 $O(64 \times 2\times q)$ 的，$q$ 是询问次数，但是出题人不想让这个做法过去，因此我们还得优化下算法。

考虑我们处理 $f$ 数组的复杂度只有 $O(64^3)$ ，我们还可以用更多的时间处理更多的东西，考虑将前面 $58$ 位分块，块大小为 $B$，定义一个新的数组 $g_{i,j,k,s,l}$ 表示考虑到了第 $i$ 块，$m = j$ ，$i + 1$ 块到 $\lfloor\frac{58}{B}\rfloor$ 的 $\operatorname{popcount}$ 为 $k$ ，第 $i$ 块的状态为 $s$ ，转移到第 $i$ 块状态为 $l$ 后 $m$ 最小是多少，这个转移可以用之前求过的$f$ 数组求，预处理的复杂度就是 $O(\lfloor\frac{58}{B}\rfloor\times2^B\times 2^B\times 58\times64)$ 

然后用和之前做法类似的想法就可以用 $g$ 数组求每一次的答案了，复杂度为 $O(q\times\lfloor\frac{58}{B}\rfloor)$ ，大概取 $B = 6$ 最优。

然而实际测试你会发现效率和暴力差不多，经过实际测试会发现这个做法常数巨大，一点一点测会发现每次调用 $g$ 数组常数巨大，因为是个五维数组，而且每一维没有什么移动的性质，导致他慢的要死，考虑优化一下这个常数。观察我们的转移，我们会发现，对于同一块，我们有三种操作模式：

- 一种是从此刻块的状态 $s$ 变为 $0$ 并且前面进位
- 从此刻状态为 $0$ 变为 $b$ 再这个块的状态
- 普通的转移

我们会发现前两种东西可以用一个四维数组存下，第三种情况其实只会发生一次，这样我们就卡掉了很多很多的常数。

对于空间来说，我们的数组需要开 `char`，因为每个数组答案都不超过 $64$ ，而且开 `int` 就会爆空间。

这题真是nt卡常，卡了至少一天半的常数，还是看了又个人过了的代码发现五维数组比四维常数大了不知道多少倍，无限乱卡，本地跑的比过的人快了交上去还是T，真是离谱。

🐍有个贼优的做法，那个五维数组小了不少。

## **D**

**upsolved by **

### 题意



### 题解



## **E**

**upsolved by **

### 题意



### 题解



## **F**

**upsolved by **

### 题意



### 题解



## **G**

**upsolved by **

### 题意



### 题解



## **H**

**upsolved by **

### 题意



### 题解



## **I**

**upsolved by **

### 题意



### 题解



## **J**

**upsolved by **

### 题意



### 题解



## **K**

**upsolved by **

### 题意



### 题解



## **L**

**upsolved by **

### 题意



### 题解



## **记录**

这场属于是逆了大天了，补题都难顶

0h：开局俩签到，但是一个corner case没判，WA了一发，看F好像是之前做过的原题，MJX和ZYF开想，CSK抄KDT板子

1h：听后面数理逻辑说 $\log^2$ 不知道啥算法被卡了，心慌慌，但是还是莽了一发F，过了(x。测了测KDT的速度，跑了70s，很好，完全过不去。

2h~3h：挂！3h最后想了个B的分块做法，但是很麻烦，只能慢慢写。

4h：写着写着发现咋写都得二分，值域分块就没用了，甚至无限扩大常数，然后爆T。到最后改改块大小变成WA了。

after end：ZYF B判断错了，寄！块大小应该直接变成 $\sqrt{n\log n}$ ，不然复杂度不对。

## **总结**

## **Dirt**



