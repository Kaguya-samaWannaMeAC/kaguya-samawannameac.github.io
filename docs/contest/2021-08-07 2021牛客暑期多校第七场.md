# [2021牛客暑期多校第七场](https://ac.nowcoder.com/acm/contest/11258)

| 排名    | 当场过题数 | 至今过题数 | 总题数 |
| ------- | ---------- | ---------- | ------ |
| 56/1294 | 3          | 11         | 11     |

## **A**

**upsolved by JJLeo**

### 题意

给定 $n$ 个点的完全图，每条边有一个权值，定义一个边集是好的当且仅当它将 $n$ 个点连通，一个边集的权值是所有边权的积乘以边集大小，求所有好边集的权值和。($1 \le n \le 20$)

### 题解

本题需要利用集合幂级数的相关知识解决。

> 设集合大小为 $n$，则
> 
> $$
> F(x)= \sum _{i=0} ^ {2^n-1}f_ix^i
> $$
> 
> 称作集合幂级数，这里的 $i$ 用二进制表示后可以代表一个集合，$f_i$ 代表集合 $i$ 对应的系数。
>
> 那么 FWT 的三种卷积看看作是两个集合幂级数在以一种特殊的规则在卷。
>
> 子集卷积可以看作是二元幂级数的运算，设
> 
> $$
> \begin{aligned}
> F(x,y)=\sum \limits _{i=0} ^ {2^n-1}f_ix^iy^{\operatorname{popcount}(i)} \newline
> G(x,y)=\sum \limits _{i=0} ^ {2^n-1}g_ix^iy^{\operatorname{popcount}(i)}
> \end{aligned}
> $$
> 
> 则 $x$ 卷积是 OR 卷积，而 $y$ 卷积是正常的加法卷积，也即：
> 
> $$
> \begin{aligned}
> H(x,y)=&F(x,y)G(x,y) \newline
> =&\sum_{i=0}^{2^n-1}\sum_{j=0}^{n}\sum_{a=0}^{2^n-1}\sum_{b=0}^{2^n-1}\sum_{c=0}^{n}\sum_{d=0}^{n}[a \cup b=i][c+d=j]\left[x^ay^c\right]F(x,y)\left[x^by^d\right]G(x,y)x^iy^j \newline
> =&\sum_{j=0}^{n}y^j\sum_{c=0}^j\left[y^c\right]F(x,y)\left[y^{j-c}\right]G(x,y)
> \end{aligned}
> $$
> 
> 这也就是子集卷积做法的原理，直接做复杂度是 $O\left(n^22^{2n}\right)$，但是我们可以加速 $x$ 卷积的过程，利用 FWT 后的可加性，对每个 $\left[y^j\right]F(x,y)$ 和 $\left[y^j\right]G(x,y)$ (也就是每一行) 先做 FWT，之后就可以用 $O\left(2^n\right)$ 完成一次点乘，将每个 $\left[y^j\right]H(x,y)$ (也就是每一行) 的全部点值加起来后，做一次 IFWT 即可。
>
> **需要注意的是**，$x$ 个集合的元素并上 $y$ 个集合的元素后有 $x+y$ 个元素当且仅当它们不交，利用这条性质我们只能确保所有 $\left[x^iy^{\operatorname{popcount}(i)}\right]H(x,y)$ 是对的，当然我们也只需要用到这些值。
>
> 既然第二维可以做加法卷积，那也可以做 $\exp$ 和 $\ln$，其拥有同样的组合意义，只不过是在子集卷积意义下的，我们以 $\exp$ 为例：
> 
> $$
> G(x,y)=\exp F(x,y)-1=\sum_{i=1}^{\infty} \frac{F^i(x,y)}{i!}
> $$
> 
> 这里幂级数之间的运算就是上面提到的子集卷积。
>
> 对于固定的 $\left[y^j\right]G(x,y)$，相当于数个 $\left[y^k\right]F(x,y)$ (遵循 $\exp$ 的定义) 按照 OR 卷积起来，那么和算子集卷积一样，对每个 $\left[y^j\right]F(x,y)$ 先做 FWT，这样每一列之间就是独立的了。
>
> 单独看每一列，相当于做 $y$ 这个变量的加法卷积 $\exp$，$n$ 一般不超过 $20$，套多项式板子没有必要，可以用 $\exp$ 的泰勒展开及求导得到一个 $O\left(n^2\right)$ 做法，不受模数限制：
> 
> $$
> \begin{aligned}
> G(x)&=\exp F(x)-1 \newline
> \frac{\text dG(x)}{\text dx}&=\frac{\text dF(x)}{\text dx}\exp F(x) \newline
> \frac{\text dG(x)}{\text dx}&=\frac{\text dF(x)}{\text dx}(G(x)+1) \newline
> \frac{\text dG(x)}{\text dx}&=\frac{\text dF(x)}{\text dx}+\frac{\text dF(x)}{\text dx}G(x) \newline
> (i+1)g_{i+1}&=(i+1)f_{i+1}+\sum_{j=0}^i (j+1)f_{j+1}g_{i-j} \newline
> g_{i}&=f_{i}+\frac{1}{i}\sum_{j=0}^{i-1} (j+1)f_{j+1}g_{i-1-j} \newline
> \end{aligned}
> $$
> 
> 这样我们就可以对每列 $O\left(n^2\right)$ 求出 $\exp$ 后的结果，最后对每个 $\left[y^j\right]G(x,y)$ 做 IFWT 即可。
>
> $\ln$ 是相同的，仅作公式推导：
> 
> $$
> \begin{aligned}
> G(x)&=\ln(F(x)+1) \newline
> \frac{\text dG(x)}{\text dx}&=\frac{\text dF(x)}{\text dx}\frac{1}{F(x)+1} \newline
> \frac{\text dG(x)}{\text dx}F(x)+\frac{\text dG(x)}{\text dx}&=\frac{\text dF(x)}{\text dx} \newline
> \frac{\text dG(x)}{\text dx}&=\frac{\text dF(x)}{\text dx}-\frac{\text dG(x)}{\text dx}F(x) \newline
> (i+1)g_{i+1}&=(i+1)f_{i+1}-\sum_{j=0}^i(j+1)g_{j+1}f_{i-j} \newline
> g_i&=f_i-\frac{1}{i}\sum_{j=0}^{i-1}(j+1)g_{j+1}f_{i-1-j}
> \end{aligned}
> $$

先不考虑乘以边集大小，设 $g_i$ 为边集经过的点在集合 $i$ 中的所有边集权值乘积之和，$f_i$ 为边集经过的点在集合 $i$ 中且 $i$ 连通的所有边集权值乘积之和，设：

$$
\begin{aligned}
F(x,y)=\sum \limits _{i=0} ^ {2^n-1}f_ix^iy^{\operatorname{popcount}(i)} \newline
G(x,y)=\sum \limits _{i=0} ^ {2^n-1}g_ix^iy^{\operatorname{popcount}(i)}
\end{aligned}
$$

则有：

$$
\begin{aligned}
G(x,y)&=\exp F(x,y)-1 \newline
F(x,y)&=\ln(G(x,y)+1)
\end{aligned}
$$

枚举每条边，设其边权为 $w$，将所有能选这条边的点集 $i$ 的 $g_i$ 变为 $g_i+wg_i$。这样可以在 $O(n^22^n)$ 的时间内求出全部 $g_i$，之后用集合幂级数 $\ln$ 即可求得所有 $f_i$，最终答案即为 $f_{2^n-1}$。

再考虑乘以边集大小，相当于把每个数换成一个多项式 $f(x)=\sum \limits _{i=0} ^ \infty a_ix^i$，每项系数为边集大小是 $i$ 的权值乘积和，最终答案即为 $\dfrac{\text d}{\text dx}f(1)=\sum \limits _{i=0} ^ \infty a_ii$。

我们只需维护 $f(1)$ 和 $\dfrac{\text d}{\text dx}f(1)$ 即可，两个多项式 $f(x)$ 和 $g(x)$ 相加，两者变为：

$$
\left(f(1)+g(1),\frac{\text d}{\text dx}f(1)+\frac{\text d}{\text dx}g(1)\right)
$$

两个多项式 $f(x)$ 和 $g(x)$ 相乘，两者变为：

$$
\left(f(1)g(1),g(1)\frac{\text d}{\text dx}f(1)+f(1)\frac{\text d}{\text dx}g(1)\right)
$$

使用一个二元组结构体重载运算符并取代 `int` 即可，注意求 $g_i$ 时乘以 $w$ 也应改成 $g_i$ 乘以一个多项式 $(1+wx)$，因此二元组为 $\left(1+w,w\right)$。

总时间复杂度为 $O\left(n^2 2^n\right)$。

## **B**

**upsolved by JJLeo**

### 题意



### 题解



## **C**

**upsolved by 2sozx**

### 题意

对于一个数 $x$ 每次操作后能变为 $x + \operatorname{popcount}(x)$ ，$10^7$ 个询问，每次询问 $a, b$ ，问对 $a$ 进行无限次操作后，第一个大于等于 $b$ 的数是多少，最后一起输出。 $1\le a < b < 2^{64}$

### 题解

首先我们可以发现一个显然的结论，每次移动不超过 $64$ 次，因此我们可以将 $x$ 分解，设其为 $x = M \times 2^6 + m$

首先我们定义一个数组 $f_{i, j, k}$ 表示第 $0\sim i - 1$ 位为 $0$，$m$ 为 $j$ ，$i\sim 57$ 位的 $\operatorname{popcount}$ 为 $k$ ，经过很多次移动后 $i\sim 57$ 位发生变化后 $m$ 最小是多少，这里将最后 $6$ 位与前面的 $58$ 位分开考虑。通过这个定义我们可以很容易的想出来这个 $f$ 的转移。详细的说就是 $i \not= 0$ 时，相当于 $i - 1$ 位变化两次；$i = 0$ 是让 $m$ 进位即可。


$$
f_{i,j,k} =
\begin{cases}
j + \operatorname{popcount}(j) + k - 64\quad i = 0 \wedge j + \operatorname{popcount}(j) + k \ge 64\newline
f_{i, j + \operatorname{popcount}(j) + k,k}\quad i = 0 \wedge j + \operatorname{popcount}(j) + k < 64\newline
f_{i - 1, f_{i - 1, j, k}, k + 1} \quad i \not= 0
\end{cases}
$$


转移的复杂度是 $O(64^3)$ 的。有了这个东西我们考虑如何用 $f$ 来计算答案。

考虑 $a, b$ 的二进制表示，我们可以从地位到高位转移 $a$ ，如果从这位开始，$a,b$ 到最高位的二进制表示完全相同，那么我们就可以用 $f$ 数组从这位向低位让 $a$ 始终贴着 $b$ 的上界即可。如果到最高位的二进制表示不同，那么为了要用上我们的 $f$ 数组，需要让这位的 $a$ 变成 $0$ ，然后继续考虑更高的一位。

这个做法复杂度是 $O(64 \times 2\times q)$ 的，$q$ 是询问次数，但是出题人不想让这个做法过去，因此我们还得优化下算法。

考虑我们处理 $f$ 数组的复杂度只有 $O(64^3)$ ，我们还可以用更多的时间处理更多的东西，考虑将前面 $58$ 位分块，块大小为 $B$，定义一个新的数组 $g_{i,j,k,s,l}$ 表示考虑到了第 $i$ 块，$m = j$ ，$i + 1$ 块到 $\lfloor\frac{58}{B}\rfloor$ 的 $\operatorname{popcount}$ 为 $k$ ，第 $i$ 块的状态为 $s$ ，转移到第 $i$ 块状态为 $l$ 后 $m$ 最小是多少，这个转移可以用之前求过的$f$ 数组求，预处理的复杂度就是 $O(\lfloor\frac{58}{B}\rfloor\times2^B\times 2^B\times 58\times64)$ 

然后用和之前做法类似的想法就可以用 $g$ 数组求每一次的答案了，复杂度为 $O(q\times\lfloor\frac{58}{B}\rfloor)$ ，大概取 $B = 6$ 最优。

然而实际测试你会发现效率和暴力差不多，经过实际测试会发现这个做法常数巨大，一点一点测会发现每次调用 $g$ 数组常数巨大，因为是个五维数组，而且每一维没有什么移动的性质，导致他慢的要死，考虑优化一下这个常数。观察我们的转移，我们会发现，对于同一块，我们有三种操作模式：

- 一种是从此刻块的状态 $s$ 变为 $0$ 并且前面进位
- 从此刻状态为 $0$ 变为 $b$ 再这个块的状态
- 普通的转移

我们会发现前两种东西可以用一个四维数组存下，第三种情况其实只会发生一次，这样我们就卡掉了很多很多的常数。

对于空间来说，我们的数组需要开 `char`，因为每个数组答案都不超过 $64$ ，而且开 `int` 就会爆空间。

这题真是nt卡常，卡了至少一天半的常数，还是看了又个人过了的代码发现五维数组比四维常数大了不知道多少倍，无限乱卡，本地跑的比过的人快了交上去还是T，真是离谱。

🐍有个贼优的做法，那个五维数组小了不少。

## **D**

**upsolved by JJLeo**

### 题意



### 题解



## **E**

**upsolved by JJLeo**

### 题意



### 题解



## **F**

**solved by 2sozx JJLeo**

### 题意



### 题解



## **G**

**upsolved by Bazoka13**

### 题意



### 题解



## **J**

**upsolved by JJLeo**

### 题意



### 题解



## **K**

**upsolved by JJLeo**

### 题意



### 题解





## **记录**

这场属于是逆了大天了，补题都难顶

0h：开局俩签到，但是一个corner case没判，WA了一发，看F好像是之前做过的原题，MJX和ZYF开想，CSK抄KDT板子

1h：听后面数理逻辑说 $\log^2$ 不知道啥算法被卡了，心慌慌，但是还是莽了一发F，过了(x。测了测KDT的速度，跑了70s，很好，完全过不去。

2h~3h：挂！3h最后想了个B的分块做法，但是很麻烦，只能慢慢写。

4h：写着写着发现咋写都得二分，值域分块就没用了，甚至无限扩大常数，然后爆T。到最后改改块大小变成WA了。

after end：ZYF B判断错了，寄！块大小应该直接变成 $\sqrt{n\log n}$ ，不然复杂度不对。

## **总结**

## **Dirt**



